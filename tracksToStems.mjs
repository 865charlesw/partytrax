// Batch converts part tracks into stems and organizes them into a dir structure
// See readme for a more detailed explanation
// Charles I dare you to try and convert this to a shell script lol

import fs from 'node:fs/promises';
import cp from 'node:child_process';
import { promisify } from 'node:util';
const exec = promisify(cp.exec);

/**
 * A utility to do parallel forEach's (forEaches? My spellchecker doesn't like that)
 * @type {<A, B>(array: A[], callback: (value: A) => Promise<B>) => Promise<B[]>}
 */
const mapAsync = (array, callback) => Promise.all(array.map(callback));


const RAW_DIR = './tracks/raw';

/**
 * @typedef {{
 *  rawFilePath: string;
 *  type: 'Balanced' | 'Part-Left' | 'Part-Mixed';
 *  part?: 'tenor1' | 'tenor2' | 'bari' | 'bass';
 *  newFilePath?: string;
 * }} SongFile
 *
 * @typedef {{ name: string; files: SongFile[] }} SongInfo
 */

const allRawFileNames = await fs.readdir(RAW_DIR);
/**
 * Map from song name to song info
 * @type {Map<string, SongInfo>}
 */
const songsMap = new Map();

// Sort files by song name
console.log('Parsing raw file names and generating plan:')
for (const rawFileName of allRawFileNames) {
  const songName = rawFileName
    .match(/^([\w ,:'.]+) /)[1] // Match the part before any hyphens or parens
    .replace(/ t+b+$/i, ''); // Strip off "TTBB" at the end
  let songInfo = songsMap.get(songName);
  if (!songInfo) {
    songInfo = { name: songName, files: [] }
    songsMap.set(songName, songInfo);
  }

  /** @type {Partial<SongFile>} */ const file = {
    rawFilePath: `${RAW_DIR}/${rawFileName}`,
  };

  // Determine what kind of file we're looking at
  const fileNameWithoutSongName = rawFileName.replace(songInfo.name, '');
  if (fileNameWithoutSongName.match(/left/i)) {
    file.type = 'Part-Left';
  } else if (fileNameWithoutSongName.match(/demo|balanced/i)) {
    file.type = 'Balanced';
  } else {
    file.type = 'Part-Mixed';
  }

  // Determine what section's part we're looking at
  if (file.type !== 'Balanced') {
    if (fileNameWithoutSongName.match(/tenor ?1|t1/i)) {
      file.part = 'tenor1';
    } else if (fileNameWithoutSongName.match(/tenor ?2|t2/i)) {
      file.part = 'tenor2';
    } else if (fileNameWithoutSongName.match(/bass ?1|b1|bari/i)) {
      file.part = 'bari';
    } else { // default case means we can catch "bass" without worrying about "bass 1"
      file.part = 'bass';
    }
  }

  console.log(`  "${rawFileName}" parsed as "${songInfo.name}" ${file.type} ${file.part || ''}`)
  songInfo.files.push(/** @type {SongFile} */ (file));
}

const songs = Array.from(songsMap.values());

console.log('Translating files:')
// Process all songs in parallel
await mapAsync(songs, async (songInfo) => {
  // Make a folder for the song
  const songDir = `./tracks/${songInfo.name.replace(/\W+/, '_')}`; // Replace non-alphanumeric characters with underscores because who knows what the filesystem can handle
  await fs.mkdir(songDir);

  // Translate each file in the song in parallel
  await mapAsync(songInfo.files, async (file) => {
    if (file.type === 'Part-Left') {
      file.newFilePath = `${songDir}/${file.part}.mp3`;
      const command = `ffmpeg -i "${file.rawFilePath}" -af "pan=mono|FC=FL" "${file.newFilePath}"`;
      console.log('  >' , command);
      return exec(command);
    } else if (file.type === 'Balanced') {
      // This filename is generated by spleeter. A file called vocals.mp3 will also be created in the same directory but we'll ignore it
      file.newFilePath = `${songDir}/accompaniment.mp3`;
      const command = `spleeter separate "${file.rawFilePath}" -o "${songDir}" -f "{instrument}.{codec}"`;
      console.log('  >' , command);
      return exec(command);
    } else {
      console.log(`  TODO: deal with mixed part track ${file.rawFilePath}`);
    }

  });
});

console.log('Generating manifest file at ./tracks/manifest.json');
const manifestData = songs.map((songInfo) => ({
  name: songInfo.name,
  files: songInfo.files.map((sf) => sf.newFilePath),
}));
await fs.writeFile('./tracks/manifest.json', JSON.stringify(manifestData, null, 2));
